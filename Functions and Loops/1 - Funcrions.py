# #Удаление всего что связано с переменнной и имени переменной
# #del name
# # string='HI!'
# # del string
# # print(string)
#
# #Работа функции:
# num=len('KUT') #арг. передается в йунк. в кач. входных
# #Функция выполняется
# num=3#Функция возвр. итог, который становится на место когда, вызываемого функцию
#
# #Функция print  с побочным эффектом:
# kut=print('KUT')
# print(kut)
# print(type(kut))
# #Функция небольшое действие, которое необходимо будет много раз повторять.
#
# #Функция умножения чисел
#
# def multipy(x, y):#Сигнатура функции
#     """Возвращает умножение двух чисел"""
#     #Тело функции
#     product=x*y
#     return product
# #Обязательный пропус строки
#
# #Выводит доп. инфу о функции, заключенную в тройные кавычки после определения сигнатуры функции
# print(help(multipy))
#
#
# def greet(name):
#     """Пишет какую-то там строку"""
#     print(f'Hello, {name}!')
#
# print(greet('Толян'))
# print(greet('Джеки Чан'))
# print(greet(47))
# print(help(greet))

#Внутри функций переменные имеют свои собственные значения, нежели за функциями, т.к имеюбт локальную облать видимости scopa.
#Внутри функция можно вставить еще функции, тогда такие функции будут внутренними.
#Поиск переменных по фунциями осуществляется по скоупу иррарихически вверх.
#Правило LEGB для определения scope
#Local
#Rnclosing
#Global
#Build-in


ttl=0
def func(x):
    global ttl# решает проблему инициализации переменной до объявления функции
    ttl=ttl+x
    print(ttl)

x=5
func(x)